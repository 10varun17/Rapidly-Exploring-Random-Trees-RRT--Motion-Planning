from rrt import RRT
from robot import Robot
from cspace import ConfigSpace
from visualize import visualize_rrt, visualize_traj
import numpy as np
import matplotlib.pyplot as plt

def non_linear_transform(delx, dely, x_r, curr_yaw):
    """
    Transform delx, dely control input to unicycle dynamics control input v, w.
    """
    v = (1 / x_r) * (x_r * np.cos(curr_yaw) * delx + x_r * np.sin(curr_yaw) * dely)
    w = (1 / x_r) * (-1 * np.sin(curr_yaw) * delx + np.cos(curr_yaw) * dely)

    return v, w

def simulate_path(robot:Robot, path:list[tuple], dt=0.05, tol=1e-2):
    """
    Drive the robot through the path generated by the RRT algorithm.
    """
    traj = [tuple(robot.get_state()[:2])]
    v_max = 0.9
    w_max = 1.57
    for waypoint in path[1:]:
        q_curr = np.array(robot.get_state())
        q_next = np.array(waypoint)
        dist_to_next_wp = np.linalg.norm(q_curr[:2] - q_next)

        while dist_to_next_wp > tol:
            # Compute control command to the next waypoint from the current position
            dq = q_next - q_curr[:2]
            delx = dq[0]
            dely = dq[1]

            # Convert to unicycle dynamics
            v, w = non_linear_transform(delx, dely, 0.1, q_curr[2])

            # Clip the commands and update the robot's state
            v = min(max(-v_max, v), v_max)
            w = min(max(-w_max, w), w_max)
            u = [v, w]
            robot.update_state(u)
            
            # Append the updated state to the trajectory
            q_curr = np.array(robot.get_state())
            dist_to_next_wp = np.linalg.norm(q_curr[:2] - q_next)
            traj.append(tuple(q_curr[:2]))

    return traj

if __name__ == "__main__":
    robot = Robot(1., 1., 0.)
    cspace = ConfigSpace()
    planner = RRT(q_start=(1,1), q_goal=(5,6), cspace=cspace, n_iters=500, step_size=0.3, p=0.1)
    V, E = planner.build()
    path = planner.get_path()
    trajectory = simulate_path(robot, path)

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
    visualize_rrt(planner.V, planner.E, planner.start, planner.goal, cspace, path, ax=ax1)
    visualize_traj(trajectory, cspace, ax=ax2)

    plt.tight_layout()
    plt.savefig("rrt_no_obstacle.png")
    plt.show()